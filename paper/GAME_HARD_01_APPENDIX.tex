% GAME_HARD_01_APPENDIX.tex

% APPENDIX
\section{APPENDIX}
\label{sec:appendix}

% APPENDIX - MATRIX MULT. W. BLOCKS
\subsection*{Matrix~mult.~w.~Blocks}
\begin{lstlisting}
#ifndef DV2549_FXS_MULTFLOATBASIC_FX
#define DV2549_FXS_MULTFLOATBASIC_FX

#include <CommonFloat.fx>

[ numthreads( BLOCK_SIZE, BLOCK_SIZE, 1 ) ]
void main(
	uint3 tIdx : SV_GroupThreadID,
	uint3 bIdx : SV_GroupID ) {
	const uint row = bIdx.y*BLOCK_SIZE+tIdx.y;
	const uint col = bIdx.x*BLOCK_SIZE+tIdx.x;
	if( row>=cRows || col>=cCols ) {
		return;
	}
    
	float sum = 0;
	for( uint i = 0; i<aRows; i++ ) {
		uint idxA = row*aRows+i;
		uint idxB = col+bRows*i;
		sum += mA[idxA]*mB[idxB];
	}
	mC[row*cRows+col] = sum;
}

#endif // DV2549_FXS_MULTFLOATBASIC_FX
\end{lstlisting}

\newpage
\vspace*{0.08cm} % hack

% APPENDIX - MATRIX MULT. W. BLOCKS & SHARED MEMORY
\subsection*{Matrix~mult.~w.~Blocks~and~Shared~Memory}
\begin{lstlisting}
#ifndef DV2549_FXS_MULTFLOATTILE_H
#define DV2549_FXS_MULTFLOATTILE_H

#include <CommonFloat.fx>

groupshared float mAs[BLOCK_SIZE][BLOCK_SIZE];
groupshared float mBs[BLOCK_SIZE][BLOCK_SIZE];

[ numthreads( BLOCK_SIZE, BLOCK_SIZE, 1 ) ]
void main(
	uint3 tIdx : SV_GroupThreadID,
	uint3 bIdx : SV_GroupID ) {
	const uint row = bIdx.y*BLOCK_SIZE+tIdx.y;
	const uint col = bIdx.x*BLOCK_SIZE+tIdx.x;
	
	float sum = 0;
	const uint blocks = ceil( 
		(float)aRows/(float)BLOCK_SIZE );
	for( uint i = 0; i<blocks; i++ ) {
		mAs[tIdx.y][tIdx.x] = mA[ 
			row*aRows+( i*BLOCK_SIZE+tIdx.x )];
		mBs[tIdx.y][tIdx.x] = mB[ 
			col+bRows*( i*BLOCK_SIZE+tIdx.y )];
		GroupMemoryBarrierWithGroupSync();

		for( uint j = 0; j<BLOCK_SIZE; j++ ) {
			sum += 
				mAs[tIdx.y][j]*mBs[j][tIdx.x];
		}
		GroupMemoryBarrierWithGroupSync();
	}
	if( row>=cRows || col>=cCols ) {
		return;
	}
	mC[row*cRows+col] = sum;
}

#endif // DV2549_FXS_MULTFLOATTILE_H

\end{lstlisting}
